<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pinger</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Pinger</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/ping-google.html"><strong aria-hidden="true">2.1.</strong> Ping Google</a></li><li class="chapter-item expanded "><a href="getting-started/storing-metrics.html"><strong aria-hidden="true">2.2.</strong> Storing Metrics</a></li><li class="chapter-item expanded "><a href="getting-started/status-page.html"><strong aria-hidden="true">2.3.</strong> Deploying a Status Page</a></li><li class="chapter-item expanded "><a href="getting-started/mail-on-failure.html"><strong aria-hidden="true">2.4.</strong> Mail on Check Failure</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Deploying</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Plugins</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Configuration</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Agent</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Central Organizer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Application Server</div></li></ol></li><li class="chapter-item expanded "><a href="architecture/index.html"><strong aria-hidden="true">6.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Agents</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Central Organizer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Application Server</div></li></ol></li><li class="chapter-item expanded "><a href="contributing/index.html"><strong aria-hidden="true">7.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/build-process.html"><strong aria-hidden="true">7.1.</strong> Build Process</a></li><li class="chapter-item expanded "><a href="contributing/pull-request.html"><strong aria-hidden="true">7.2.</strong> Submitting a Pull Request</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Maintaining</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Pinger</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/sdslabs/pinger" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="./pinger-logo.png" alt="Pinger" /></p>
<p>Pinger is an uptime and status monitoring application. It is an open-source
implementation of platforms used to create status pages. Unlike other
alternatives, Pinger can be deployed to create a standalone status page
from a config file as well as a complete platform to manage users, checks,
pages, alerts, etc.</p>
<ul>
<li>Issue Tracker: <a href="https://github.com/sdslabs/pinger/issues">https://github.com/sdslabs/pinger/issues</a></li>
<li>Source Code: <a href="https://github.com/sdslabs/pinger/issues">https://github.com/sdslabs/pinger</a></li>
</ul>
<blockquote>
<p><strong>Note:</strong> Pinger is currently being developed actively. If you would like
to contribute to the project, head over to the repository hosted on
<a href="https://github.com/sdslabs/pinger">Github</a>. Contribution guidelines are
available in this documentation <a href="./contributing/index.html">here</a>.</p>
</blockquote>
<h2><a class="header" href="#license" id="license">License</a></h2>
<p>Pinger, all the source code, is released under the
<a href="https://github.com/sdslabs/pinger/blob/main/LICENSE">MIT License</a>.</p>
<h2><a class="header" href="#credits" id="credits">Credits</a></h2>
<p><a href="https://sdslabs.co"><img src="./sdslabs-logo.png" alt="Made by SDSLabs" /></a></p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>The Pinger binary is all you need to create your own status page.</p>
<h2><a class="header" href="#installing" id="installing">Installing</a></h2>
<p>Here are several ways you can install Pinger.</p>
<h3><a class="header" href="#downloading-the-binary" id="downloading-the-binary">Downloading the binary</a></h3>
<p>You can download the binary from our
<a href="https://github.com/sdslabs/pinger/releases">Github releases</a>. Everything
is packaged inside the binary, including, the frontend.</p>
<!-- TODO(vrongmeal): Add curl request to download after a release -->
<h3><a class="header" href="#docker" id="docker">Docker</a></h3>
<p>You can directly use the docker image to run Pinger. Use the docker image
hosted on
<a href="https://github.com/orgs/sdslabs/packages?ecosystem=docker&amp;repo_name=pinger">Github packages</a>.</p>
<!-- TODO(vrongmeal): Add command to run a container after a release -->
<h3><a class="header" href="#building-from-source" id="building-from-source">Building from source</a></h3>
<p>You can head over to the <a href="getting-started/../contributing/index.html">contribution section</a>
of this documentation to see how to build the project from scratch.</p>
<h1><a class="header" href="#ping-google" id="ping-google">Ping Google</a></h1>
<p>Here, we'll deploy a status page using Pinger in the standalone mode, i.e.,
without complex deployment of the complete platform. But before that we need
to learn how to run checks.</p>
<h2><a class="header" href="#what-is-a-check" id="what-is-a-check">What is a Check?</a></h2>
<p>Check, in hindsight, is a request sent to specified target which has its
response verified through some conditions which determine whether the request
returned valid response or not. These conditions might vary depending upon
the protocol of the request. For example, an HTTP request can be checked
from the status code received in the response.</p>
<h2><a class="header" href="#writing-the-configuration-file" id="writing-the-configuration-file">Writing the configuration file</a></h2>
<p>For specifying the checks in the status page, we need to write a config file.
We will start by writing an ICMP check for <strong>google.com</strong>. This will be
equivalent of running the command:</p>
<pre><code class="language-sh">$ ping google.com
</code></pre>
<p>The config file can be written in any of the following formats – YAML, TOML
or JSON. To create the status page we will be using the <code>agent</code> command which
takes the default file path to be <code>./agent.yml</code> so create a file with the
same name.</p>
<pre><code class="language-yaml"># agent.yml

# We need to tell Pinger to run the agent in standalone mode since the
# default behaviour is something else.
standalone: true

# Configuration for where metrics are stored.
metrics:
  backend: log # We will just log them on the console for now

# Interval after which metrics are logged into database.
interval: 5s

# All the checks we need to run.
checks:
  - id: ping-google # unique ID
    name: Ping Google # human-readable name
    interval: 3s # Ping every 3 seconds
    timeout: 0.5s # Timeout if it takes longer than half a second
    input:
      type: ICMP # Protocol
    output:
      type: TIMEOUT # Condition for success/failure
    target: # Target to hit/request
      type: ADDRESS
      value: google.com
</code></pre>
<h2><a class="header" href="#running-the-check" id="running-the-check">Running the check</a></h2>
<p>Now that we have the config file ready, we can launch our agent to ping the
Google servers. Assuming you have the Pinger binary, run the following
command:</p>
<pre><code class="language-sh">$ path/to/pinger agent
INFO[0005] metrics for check (ping-google) Ping Google   check_id=ping-google check_name=&quot;Ping Google&quot; duration=79.065304ms is_successful=true is_timeout=false start_time=&quot;2020-12-29 22:28:09.313387 +0530 IST m=+0.024071573&quot;
INFO[0005] metrics for check (ping-google) Ping Google   check_id=ping-google check_name=&quot;Ping Google&quot; duration=43.521461ms is_successful=true is_timeout=false start_time=&quot;2020-12-29 22:28:12.314517 +0530 IST m=+3.025195953&quot;
INFO[0010] metrics for check (ping-google) Ping Google   check_id=ping-google check_name=&quot;Ping Google&quot; duration=49.180263ms is_successful=true is_timeout=false start_time=&quot;2020-12-29 22:28:15.318509 +0530 IST m=+6.029181599&quot;
INFO[0010] metrics for check (ping-google) Ping Google   check_id=ping-google check_name=&quot;Ping Google&quot; duration=500ms is_successful=false is_timeout=true start_time=&quot;2020-12-29 22:28:18.318521 +0530 IST m=+9.029187048&quot;
</code></pre>
<p>You will get an output similar to the one above. Each 5 seconds we get logs
for the metrics that we collected. We can also see the start times for each
log is 3 seconds apart, which is what we set for our check. Finally, the last
check is considered as a failure, given it took more than the set limit of
half a second (or 500 milli-second).</p>
<h1><a class="header" href="#storing-metrics" id="storing-metrics">Storing Metrics</a></h1>
<p>Currently we only logged the metrics on the console. In long term, we would
want to persist the metrics in a time-series database. Let's see how.</p>
<h2><a class="header" href="#setting-up-timescaledb" id="setting-up-timescaledb">Setting up TimescaleDB</a></h2>
<p>Pinger supports <a href="https://www.timescale.com/">TimescaleDB</a> as of now.
Timescale is a PostgreSQL extension for storing time-series data.</p>
<p>Using the instructions
<a href="https://docs.timescale.com/latest/getting-started/installation">here</a>
we can set it up. For this tutorial we can use Docker to spawn a container
which is Timescale ready.</p>
<pre><code class="language-sh">$ docker run -d --name timescaledb -p 5432:5432 \
  -e POSTGRES_PASSWORD=password timescale/timescaledb:2.0.0-pg12
</code></pre>
<p>This will start a PostgreSQL instance on <code>:5432</code> with Timescale installed,
the user <code>postgres</code> having password <code>password</code>.</p>
<p>Before we configure our storage, we should create a database to store the
data in.</p>
<pre><code class="language-sh"># This step is just to interactively exec into the container.
# If Timescale was set up natively into the system, it is not required.
$ docker exec -it 7e13ffbb3612 /bin/bash
# Open the postgres shell
$ psql -U postgres postgres
# Create a database named `pinger`
$ CREATE DATABASE pinger;
# List databases and verify that it is created
$ \l
                                   List of databases
      Name      |  Owner   | Encoding |  Collate   |   Ctype    |   Access privileges
----------------+----------+----------+------------+------------+-----------------------
 pinger         | postgres | UTF8     | en_US.utf8 | en_US.utf8 |
 postgres       | postgres | UTF8     | en_US.utf8 | en_US.utf8 |
 template0      | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +
                |          |          |            |            | postgres=CTc/postgres
 template1      | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +
                |          |          |            |            | postgres=CTc/postgres
(4 rows)

</code></pre>
<p>Now that we have created our database, we can configure the agent to use it.</p>
<h2><a class="header" href="#configuring-storage-backend" id="configuring-storage-backend">Configuring storage backend</a></h2>
<p>Now, we can update our config file replacing the log metrics backend with
the timescale instance.</p>
<pre><code class="language-yaml"># agent.yml

# ...

# The new metrics configuration should look like this
metrics:
  backend: timescale
  host: 127.0.0.1
  port: 5432
  username: postgres
  password: password
  db_name: pinger
  ssl_mode: false # Let's just keep it off for now

# ...
</code></pre>
<p>That's it. We can restart our agent and see metrics being stored into the
database.</p>
<pre><code class="language-sh">$ path/to/pinger agent
</code></pre>
<p>Now we can change the database from Postgres shell and see if metrics were
actually collected into the database.</p>
<pre><code class="language-sh">$ \c pinger
You are now connected to database &quot;pinger&quot; as user &quot;postgres&quot;.
$ SELECT * FROM metrics;
  check_id   | check_name  |          start_time           | duration  | timeout | success
-------------+-------------+-------------------------------+-----------+---------+---------
 ping-google | Ping Google | 2020-12-29 19:11:06.926541+00 |  72592580 | f       | t
 ping-google | Ping Google | 2020-12-29 19:11:09.931472+00 | 116203210 | f       | t
 ping-google | Ping Google | 2020-12-29 19:11:12.930745+00 |  54831874 | f       | t
 ping-google | Ping Google | 2020-12-29 19:11:15.930645+00 |  39025993 | f       | t
(4 rows)
</code></pre>
<p>You should see something like above.</p>
<p>Hurray! We have successfully set up a persistent storage backend for our
metrics.</p>
<h1><a class="header" href="#deploying-a-status-page" id="deploying-a-status-page">Deploying a Status Page</a></h1>
<p>Deploying a status page is quite easy. We just need to set a boolean equal
to <code>true</code>, and set a couple other variables.</p>
<h2><a class="header" href="#configuration" id="configuration">Configuration</a></h2>
<p>Add the following to the configuration file.</p>
<pre><code class="language-yaml"># agent.yml

# ...

page:
  deploy: true
  allowed_origins: ['*'] # For now allow every origin
  name: My Status Page
</code></pre>
<h2><a class="header" href="#seeing-metrics-on-browser" id="seeing-metrics-on-browser">Seeing metrics on browser</a></h2>
<p>Open up your browser and visit
<a href="http://127.0.0.1:9010/">http://127.0.0.1:9010/</a> and you'll be greeted by a
beautiful status page displaying metrics for your check.</p>
<p><img src="getting-started/./status-page.png" alt="Status Page" /></p>
<p>Similarly, we can add more checks to our config, and they'll magically
appear on the status page. We can also configure the logo and favicon of
the status page. Use <a href="getting-started/">this config reference</a> on how to do it.</p>
<!-- TODO(vrongmeal): Fix the link once config references are added -->
<p>We have finally created a status page, and it was super easy. Let's
continue this journey with one of the coolest features – alerts.</p>
<h1><a class="header" href="#mail-on-check-failure" id="mail-on-check-failure">Mail on Check Failure</a></h1>
<p>Pinger can send alerts when a check fails, or when a check comes back from
the dead.</p>
<h2><a class="header" href="#updating-the-check" id="updating-the-check">Updating the check</a></h2>
<p>Previously we set a timeout for <code>0.5s</code> which rarely timed out. Let's change
it to <code>0.1s</code> to encounter more failures.</p>
<pre><code class="language-yaml"># agent.yml

# ...

checks:
  - id: ping-google
    name: Ping Google
    interval: 3s
    timeout: 0.1s
    input:
      type: ICMP
    output:
      type: TIMEOUT
    target:
      type: ADDRESS
      value: google.com

# ...
</code></pre>
<p>Let's run the check and see if we encountered any failures:</p>
<pre><code class="language-sh">$ path/to/pinger agent
</code></pre>
<p>After a few seconds, let's query our database for metrics.</p>
<pre><code class="language-sh"># In the postgres shell
$ SELECT * FROM metrics;
  check_id   | check_name  |          start_time           | duration  | timeout | success
-------------+-------------+-------------------------------+-----------+---------+---------
...
 ping-google | Ping Google | 2020-12-29 19:58:54.686244+00 |  43848273 | f       | t
 ping-google | Ping Google | 2020-12-29 19:58:57.686358+00 | 100000000 | t       | f
 ping-google | Ping Google | 2020-12-29 19:59:00.685532+00 |  45252482 | f       | t
 ping-google | Ping Google | 2020-12-29 19:59:03.682839+00 |  44708297 | f       | t
 ping-google | Ping Google | 2020-12-29 19:59:06.681564+00 | 100000000 | t       | f
 ping-google | Ping Google | 2020-12-29 19:59:09.683893+00 |  73249643 | f       | t
...
</code></pre>
<p>Looks like we did encounter a few failures. Amazing. Let's set up an alert
now.</p>
<h2><a class="header" href="#adding-senders-information" id="adding-senders-information">Adding sender's information</a></h2>
<p>We need to inform Pinger about the account from where to send the emails.
This means you need to provide an email and password in configuration file.
I'll be using my personal Gmail account for this.</p>
<pre><code class="language-yaml"># agent.yml

# ...

alerts:
  - service: mail
    host: smtp.gmail.com # Since I'll be using a Gmail Account
    port: 587
    user: &lt;email&gt;
    secret: &lt;password&gt;
</code></pre>
<p>Replace the <code>&lt;email&gt;</code> and <code>&lt;password&gt;</code> with your email account and password
respectively.</p>
<blockquote>
<p><strong>Note:</strong> You might need to turn on <em><strong>Less Secure App Access</strong></em> in your
Google account security settings.</p>
</blockquote>
<p>Once done, we can add a mail alert to our check.</p>
<h2><a class="header" href="#setting-alert-for-the-check" id="setting-alert-for-the-check">Setting alert for the check</a></h2>
<p>In the check configuration, we need to add what alerts are required to be
sent.</p>
<pre><code class="language-yaml"># agent.yml

# ...

checks:
  - # ...
    alerts:
      - service: mail
        target: &lt;email&gt; # For now just send the mail to yourself

# ...
</code></pre>
<p>We can now start our agent and see if we get any mail.</p>
<h2><a class="header" href="#checking-mails" id="checking-mails">Checking mails</a></h2>
<p>Start the agent again and look for any new mails from yourself.</p>
<pre><code class="language-sh">$ path/to/pinger agent
</code></pre>
<p>Open up your mail, and you'll see one like this:</p>
<p><img src="getting-started/./alert-mail.png" alt="Alert Mail" /></p>
<blockquote>
<p><strong>TODO:</strong> An email is sent each time the agent is re-started. Rather,
what should happen is, we should fetch the previous state, if any, from
the database and then see if we want to alert the user.</p>
</blockquote>
<h1><a class="header" href="#architecture" id="architecture">Architecture</a></h1>
<blockquote>
<p><strong>Note:</strong> This document also acts as a guideline for components being
developed.</p>
</blockquote>
<p>To understand how Pinger works internally, first, we need to understand
exactly what Pinger does. We will dive into all the components and
understand various aspects and how the deployment can be scaled for all of
them.</p>
<h2><a class="header" href="#key-terms" id="key-terms">Key Terms</a></h2>
<p>Before we begin with the explanation, let's get familiar with some terms
that might be frequently used:</p>
<ul>
<li><strong>Check:</strong> Anything that can be pinged. <em>Say, pinging google.com using</em>
<em>HTTP protocol and checking for status code 200.</em></li>
<li><strong>Metric:</strong> Result of a ping. <em>Whether google.com returned status 200</em>
<em>in reasonable time or not.</em></li>
<li><strong>Controller:</strong> Something that runs a specific task again and again at
regular intervals of time.</li>
<li><strong>Manager:</strong> Manages multiple controllers together and collects
statistics from each of them.</li>
<li><strong>Page (or Status Page):</strong> A collection of various checks and their corresponding
metrics.</li>
</ul>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>Pinger will typically be deployed in one of the two modes:</p>
<ul>
<li><strong>Standalone:</strong> An <em>agent</em> deployed on a single node to execute checks
and collect metrics. A status page can be deployed as well. Everything
is configured via a configuration file.</li>
<li><strong>Complete Application:</strong> Includes user auth, a dedicated dashboard to
manage checks, pages, etc. Supports distribution of load over multiple
nodes. Comprises multiple components that we will understand in this
section.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> In this section we will mainly focus on the architecture of
the complete application, since, standalone mode is simply one
component, <em>the agent</em>, interacting with a database. Anyways, we will
still go into depth of <a href="architecture/./the-agent.html">agent</a> which will give you a
better overview of how standalone mode actually works.</p>
</blockquote>
<p>A typical user would create their account, create a few checks, and then
create status pages comprising those checks. Creating a page, or adding an
incident to a page is not a complicated task, rather a simple CRUD
operation. The difficult part is creating a check. That's because once a
check has been created in the database we also need to execute it. A
check is like a cron job that keeps on running forever at regular 
intervals. We would usually want to distribute the load of checks on 
various nodes, so, separating this component makes sense. This component
is called an <strong>agent.</strong></p>
<p>There can be multiple agents distributed across various nodes, and hence,
we would need a central entity to balance the load among the agents. The
<strong>central organizer</strong> is responsible for distributing checks among the
various agents.</p>
<p>We also need an API server to interact with the user dashboard, or what
we call, a <strong>client.</strong> An <strong>app server</strong> does exactly that.</p>
<h2><a class="header" href="#flow-of-a-request" id="flow-of-a-request">Flow of a request</a></h2>
<p>Let's take the example of creating a check. <strong>Client</strong> requests the <strong>app</strong>
<strong>server,</strong> which inserts the check into <strong>app database.</strong> As we remember,
inserting into the database isn't enough for a check. We need check to run,
indefinitely. One choice could have been to just spawn a controller for
the check. The problem would be that we couldn't have been able to scale
or distribute checks over multiple nodes. So what we do instead is keep
dedicated <strong>agents</strong> on multiple nodes, which in hindsight, are just a
wrapper around a <em>manager of controllers for checks.</em></p>
<p>We want things to be atomic, i.e., checks should be assigned to agents when
created in the database. We also need to balance the load between all the
nodes and assign checks accordingly. Both the aforementioned reasons result
in an independent entity which can accept new checks from the database
and assigns them to the agent. It's the <strong>central organizer.</strong></p>
<p>We also need to store the metrics. Usually the database we need to store
metrics and application data would be different for two reasons:</p>
<ol>
<li>We would store metrics in a time-series database and not every general
purpose database supports high performance time series queries.</li>
<li>We want to scale the metrics database much differently than the app
database.</li>
</ol>
<p>So an overview of our deployment would look something like:</p>
<p><img src="architecture/./architecture-overview.jpg" alt="Architecture Overview" /></p>
<p>We'll now dive into each component individually to analyse how they
function.</p>
<h1><a class="header" href="#contributing" id="contributing">Contributing</a></h1>
<blockquote>
<p><strong>Note:</strong> This guide is for developers who want to make changes to the
Pinger codebase. If you want to create your Pinger plugin, there's
a completely different section dedicated for it.</p>
</blockquote>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>These include some tools like the Go compiler and time series database for
storing metrics.</p>
<h3><a class="header" href="#build-dependencies" id="build-dependencies">Build dependencies</a></h3>
<p>Before beginning make sure you have all the required tools installed:</p>
<ul>
<li><a href="https://golang.org/doc/install">Go</a> <code>v1.16.x</code></li>
<li><a href="https://developers.google.com/protocol-buffers/docs/gotutorial#compiling-your-protocol-buffers">Protobuf for Golang</a>
<ul>
<li><a href="https://github.com/protocolbuffers/protobuf/releases"><code>protoc</code></a> <code>v3.14.x</code></li>
<li><a href="https://google.golang.org/protobuf/cmd/protoc-gen-go"><code>protoc-gen-go</code></a> <code>v1.25.x</code></li>
<li><a href="https://google.golang.org/grpc/cmd/protoc-gen-go-grpc"><code>protoc-gen-go-grpc</code></a> <code>v1.0.x</code></li>
</ul>
</li>
<li><a href="https://golangci-lint.run/usage/install/">Golang CI Lint</a> <code>v1.32.2</code></li>
<li><a href="https://rust-lang.github.io/mdBook/cli/index.html">mdBook</a> <code>v0.4.4</code></li>
</ul>
<h3><a class="header" href="#runtime-dependencies" id="runtime-dependencies">Runtime Dependencies</a></h3>
<p>Externally, Pinger only relies on databases.</p>
<ul>
<li><a href="https://www.postgresql.org/download/">PostgreSQL</a> <code>v12</code></li>
<li><a href="https://docs.timescale.com/latest/getting-started/installation">Timescale</a> <code>v2.0</code></li>
</ul>
<h2><a class="header" href="#make-pinger" id="make-pinger">Make Pinger</a></h2>
<p>Before we can do anything, ewe need to fetch the source code present in
<a href="https://github.com/sdslabs/pinger">this Github repository</a>.</p>
<pre><code class="language-sh"># If you use SSH
$ git clone git@github.com:sdslabs/pinger.git
# or with HTTP
$ git clone https://github.com/sdslabs/pinger.git
$ cd pinger
</code></pre>
<p>Pinger uses GNU Make. We can run a simple make command to build the Pinger
binary as well as the documentation.</p>
<blockquote>
<p><strong>Note:</strong> In most of what we will learn in this section of documentation,
everything is done using <code>make</code>. If you're ever stuck, run <code>make help</code>
and hopefully you'll find something useful.</p>
</blockquote>
<pre><code class="language-sh">$ make all
</code></pre>
<p>The above command might take a while but at the end you should have an
executable called <code>pinger</code> and documentation built in the <code>docs/book</code>
directory.</p>
<p>We should take a deeper look into the build process and understand how
to use the <code>Makefile</code> for our development flow.</p>
<h1><a class="header" href="#build-process" id="build-process">Build Process</a></h1>
<p>We won't be running <code>make all</code> everytime. Since the command builds all the
components, it would take longer than usual when changing a couple lines in
one part of the code.</p>
<p>Currently we need to build three things:</p>
<ol>
<li>Binary</li>
<li>Docker Image</li>
<li>Documentation</li>
</ol>
<p>Let's take a look at both of them individually.</p>
<h2><a class="header" href="#binary" id="binary">Binary</a></h2>
<p>The binary packs all the static files, including the CSS and JavaScript files,
required for the frontend. Once we have our resources ready, we can build the
executable using the <code>make build</code> command. We have <code>VERSION</code> flag for setting
the version of the binary.</p>
<pre><code class="language-sh"># Building the binary
$ make build VERSION=1.0.1
</code></pre>
<p>The binary can be built in development mode which enables serving static files
from the file-system itself, instead of embedding them. It's works better for
development workflow since changes in static files don't require to rebuild the
Pinger executable.</p>
<pre><code class="language-sh">$ make build DEV=on
</code></pre>
<blockquote>
<p><strong>Note:</strong> This does pose the constraint that any Pinger command has to
be executed in the repository's root directory. This shouldn't be an
issue while developing.</p>
</blockquote>
<h3><a class="header" href="#protobuf" id="protobuf">Protobuf</a></h3>
<p>When making changes to a <code>.proto</code> file, we need to compile it into the
equivalent Go code. These generated files (<code>*.pb.go</code>) need to be committed.</p>
<pre><code class="language-sh">$ make proto
</code></pre>
<h2><a class="header" href="#docker-image" id="docker-image">Docker Image</a></h2>
<p><code>Dockerfile</code> for the image is present in the root directory. To build the
image, use <code>make docker</code> command. This generates an image with tag –
<code>pinger:dev</code>. To change the tag, we can use the <code>TAG</code> option for make
command.</p>
<pre><code class="language-sh">$ make docker TAG=&quot;pinger:v1.2.3&quot;
</code></pre>
<blockquote>
<p><strong>Note:</strong> In case of docker image, version is extracted from the tag.
For example: in the aforementioned case, version of the binary will 
set to <code>v1.2.3</code>.</p>
</blockquote>
<h2><a class="header" href="#documentation" id="documentation">Documentation</a></h2>
<p>Documentation is not (yet) packaged into the binary. We currently host it
using <a href="https://pages.github.com/">Github Pages</a>. We use
<a href="https://rust-lang.github.io/mdBook/">mdBook</a> as the documentation
framework. Make sure you have that installed in your <code>$PATH</code>.</p>
<p>You can build the documentation using <code>make docs</code> command. This generates
the documentation in <code>docs/book</code> directory. While developing you might
require to watch the <code>docs</code> directory. We can again use the <code>DEV=on</code>
option in that case.</p>
<pre><code class="language-sh"># To build the documentation
$ make docs
# Builds the documentation, watches for changes and serves on :3000
$ make docs DEV=on
</code></pre>
<h1><a class="header" href="#submitting-a-pull-request" id="submitting-a-pull-request">Submitting a Pull Request</a></h1>
<p>These are a few guidelines that need to be followed in-order to make
changes in the main repository.</p>
<h2><a class="header" href="#pre-commit" id="pre-commit">Pre-commit</a></h2>
<p>There are a few things to take care of before committing your changes.</p>
<h3><a class="header" href="#vendoring" id="vendoring">Vendoring</a></h3>
<p>All the dependencies in our repository are vendored. All the dependencies
are listed in <code>go.mod</code> file and are maintained in the <code>vendor</code> directory.
When updating/adding/deleting a dependency, run the following to keep the
<code>vendor</code> up-to-date:</p>
<pre><code class="language-sh">$ make vendor
</code></pre>
<p>This will cleanup unused dependencies from <code>go.mod</code> as well as add new
dependencies to <code>vendor</code>.</p>
<h3><a class="header" href="#lint" id="lint">Lint</a></h3>
<p>We use <a href="https://golangci-lint.run/">golangci-lint</a> to lint our code. Each
commit should pass all the lint checks. To ensure that it does, use the
<code>make lint</code> command. Many times, these errors might be related to
formatting of the code. These are usually auto-fixable. <code>make fmt</code> fixes
all the errors that might be resolved automatically.</p>
<pre><code class="language-sh"># To check for linting errors
$ make lint
# To fix auto-fixable errors
$ make fmt
</code></pre>
<h3><a class="header" href="#other-checks" id="other-checks">Other checks</a></h3>
<p>Apart from the fact that the code should build successfully, we need to
take care of following:</p>
<ul>
<li>Ensure that you have compiled any protobuf that may have been updated.</li>
<li>The Docker image should be built successfully as well.</li>
</ul>
<h2><a class="header" href="#commits" id="commits">Commits</a></h2>
<p>Break only logical changes into multiple commits. Commits such as &quot;fix 
typo&quot; or &quot;address review commits&quot; should be squashed into the one
logical commit. Each commit should individually pass tests and lint check
No separate commit should be made to fix these.</p>
<h3><a class="header" href="#commit-messages" id="commit-messages">Commit Messages</a></h3>
<p>Each commit message consists of a header, a body and a footer. The header
has a special format that includes a scope and a subject:</p>
<pre><code>&lt;scope&gt;: &lt;subject&gt;
&lt;BLANK LINE&gt;
&lt;body&gt;
&lt;BLANK LINE&gt;
&lt;footer&gt;
</code></pre>
<p>Any line of the commit message cannot be longer 76 characters! This allows
the message to be easier to read on github as well as in various git tools.</p>
<h4><a class="header" href="#scope" id="scope">Scope</a></h4>
<p>The scope could be anything specifying place/context of the commit change.
When making changes to Go code, this will most likely be the package name
where the changes are made. For documentation changes scope will be <code>docs</code>
and for UI changes scope will be <code>ui</code>.</p>
<blockquote>
<p><strong>Note:</strong> Scope should not be capitalized. <code>docs</code> should not be spelled
<em><code>Docs</code></em>.</p>
</blockquote>
<h4><a class="header" href="#subject" id="subject">Subject</a></h4>
<p>The subject contains succinct description of the change:</p>
<ul>
<li>Use the imperative, present tense: &quot;change&quot; not &quot;changed&quot; nor &quot;changes&quot;.</li>
<li>Do capitalize first letter.</li>
<li>Add a dot (.) at the end.</li>
</ul>
<h4><a class="header" href="#body" id="body">Body</a></h4>
<p>The body should include the motivation for the change and contrast this with
previous behavior. Just as in the <strong>subject</strong>, try to use the imperative,
present tense: &quot;change&quot; not &quot;changed&quot; nor &quot;changes&quot;, though, this rule is
not enforced for the body.</p>
<h4><a class="header" href="#footer" id="footer">Footer</a></h4>
<p>The footer should contain any information about <strong>Breaking Changes</strong> and is
also the place to reference issues that this commit <strong>Closes</strong>.</p>
<p>An example of a good commit message would be:</p>
<pre><code>exporter: Update timescale exporter to use Gorm v2.

Previously timescale exporter used Gorm v2 which did not support batch
insert resulting in raw SQL queries. Gorm v2 now includes batch insert,
hence, the same is used to refactor the exporter queries.

Closes #123

Signed-off-by: Contributer &lt;example@contributor.com&gt;
</code></pre>
<h2><a class="header" href="#pull-request" id="pull-request">Pull Request</a></h2>
<p>Pull requests follows same guidelines as mentioned for the commit messages.
The title should give a clear idea of what it is about, followed by a
descriptive body and should mention what issue it resolves (if any).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
